(1) 位、比特、字节
1位 = 1 bit    // A 0 or 1 indicates a bit.
1 byte(字节) = 8 bit(比特)

(2) 按位移动操作符
按位移动操作符有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。
i. << (左移)
该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。
For example, 9 << 2 yields 36:
9 (base 10): 00000000000000000000000000001001 (base 2)
9 << 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)
在数字 x 上左移 y 比特得到 x * 2^y.

ii. >> (有符号右移)
该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。
例如， 9 >> 2 得到 2:
9 >> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)
相比之下， -9 >> 2 得到 -3，因为符号被保留了。
-9 (base 10): 11111111111111111111111111110111 (base 2)
-9 >> 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)

iii. >>> (无符号右移)
该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）
对于非负数，有符号右移和无符号右移总是返回相同的结果。例如 9 >>> 2 和 9 >> 2 一样返回 2：
是对于负数却不尽相同。 -9 >>> 2 产生 1073741821 这和 -9 >> 2 不同
-9 >>> 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)

(3) 其他按位操作符
按位与（ AND）	a & b	对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。
按位或（OR）	a | b	对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。
按位异或（XOR）	a ^ b	对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。
按位非（NOT）	~ a	反转操作数的比特位，即0变成1，1变成0。
左移（Left shift）	a << b	将 a 的二进制形式向左移 b (< 32) 比特位，右边用0填充。
有符号右移	a >> b	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。
无符号右移	a >>> b	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。

(4) 10进制和2进制的转换
10进制->2进制：比如 2->10     2/2 = 1...0
                             1/2 = 0...1
                             把余数从下往上写出来为10，即2的二进制形式    
2进制->10进制：比如 11->3       1*2^1 + 1*2^0 = 3







